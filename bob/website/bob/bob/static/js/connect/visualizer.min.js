var gameImageSprite = new Image();

function visualize(url, size)
{
    gameImageSprite.src = "../../../static/img/connect/sprite.png";
    gameImageSprite.onload = function()
    {
        loadReplay(url);
        gamePieceSize = size;
    };
}

function initialize()
{
    gameCanvas = document.getElementById('game-canvas').getContext('2d');
    $("#game-canvas").attr("width",  gamePieceSize * (gameReplay.settings.columns + 2));
    $("#game-canvas").attr("height", gamePieceSize * (gameReplay.settings.rows + 2));

    gameMoveMaximum = gameReplay.moves.length;

    $("#game-turn-display-maximum").text(gameMoveMaximum.toString());
    $("#game-turn-input").val("0");
    $("#game-turn-input").change(function()
    {
        var value = parseInt($("#game-turn-input").val(), 10);
        if (!isNaN(value))
        {
            setTurn(value);
        }
        $("#game-turn-input").val(gameMoveCurrent.toString());
    });

    $("#game-button-previous").click(function()
    {
        setTurn(gameMoveCurrent - 1);
    });

    $("#game-button-next").click(function()
    {
        setTurn(gameMoveCurrent + 1);
    });

    $("#game-button-play-pause").click(function()
    {
        togglePlay();
    });
        
    drawEmptyBoard(gameReplay.settings.columns, gameReplay.settings.rows, gamePieceSize);
}

//----------------------------------------------------------------------------
// GLOBAL STATE

var gameLoaded = false;
var gameReplay = {};
var gameCanvas = null;
var gameMoveCurrent = 0;
var gameMoveMaximum = 0;
var gamePlayerNext = "black"

var spriteSectionData =
  [ [16, 0,  16, 16]
  , [0,  0,  16, 16]
  , [0,  16, 16, 16]
  , [16, 16, 16, 16]
  , [32, 16, 16, 16]
  , [0,  32, 16, 16]
  , [16, 32, 16, 16]
  , [32, 32, 16, 16]
  , [0,  48, 16, 16]
  , [16, 48, 16, 16]
  , [32, 48, 16, 16]
  ]

var spriteSquareBlack = 0; 
var spriteSquareWhite = 1;
var spriteSquareEmptyTL = 2;
var spriteSquareEmptyT  = 3;
var spriteSquareEmptyTR = 4;
var spriteSquareEmptyL = 5;
var spriteSquareEmpty  = 6;
var spriteSquareEmptyR = 7;
var spriteSquareEmptyBL = 8;
var spriteSquareEmptyB  = 9;
var spriteSquareEmptyBR = 10;

var gamePieceSize = 32;
var gameMovesInit = 1;
var gameMovesTurn = 2;

var playerIntervalID = null;
var playerPlaying = false;
var playerSpeed = 500;

function newTurn()
{
    return (gameMoveCurrent == gameMovesInit) ||
           (gameMoveCurrent >  gameMovesInit && ((gameMoveCurrent - gameMovesInit) % gameMovesTurn) == 0);
}

function togglePlay()
{
    if (playerPlaying)
    {
        playerGamePause();
    }
    else
    {
        playerGameResume();
    }
}

function playerGameResume()
{
    playerIntervalID = window.setInterval(function()
    {
        setTurn(gameMoveCurrent + 1);
    }
    , playerSpeed);

    $("#game-icon-play-pause").attr("class", "icon-pause");
    playerPlaying = true;
}

function playerGamePause()
{
    clearInterval(playerIntervalID);
    $("#game-icon-play-pause").attr("class", "icon-play");
    playerPlaying = false;
}

function otherPlayer(player)
{
    if (player == "black") return "white";
    if (player == "white") return "black";
}

//----------------------------------------------------------------------------
// LOADING FUNCTION

function loadReplay(url)
{
    jQuery.getJSON(url, function(data)
    {
        gameReplay = data;
        gameReplayLoaded = true;
        gameTurnMaxinum = gameReplay.moves.length;
        initialize();
    });
}

//----------------------------------------------------------------------------
// LOADING FUNCTION

function setTurn(turn)
{
    turn = Math.min(Math.max(turn, 0), gameMoveMaximum);

    while (turn != gameMoveCurrent)
    {
        if (gameMoveCurrent > turn)
        {
            drawMovePrev();
            if (newTurn())
            { 
                gamePlayerNext = otherPlayer(gamePlayerNext);
            }
            gameMoveCurrent = gameMoveCurrent - 1;
        }
        if (gameMoveCurrent < turn)
        {
            drawMoveNext();
            gameMoveCurrent = gameMoveCurrent + 1;
            if (newTurn())
            {
                gamePlayerNext = otherPlayer(gamePlayerNext);
            }
        }
    }

    if (gameMoveCurrent == gameMoveMaximum)
    {
        playerGamePause();
    }

    synchronizeUI();
}

function synchronizeUI()
{
    $("#game-turn-input").val(gameMoveCurrent.toString());
}

//----------------------------------------------------------------------------
// Function that draws an empty board.
function drawEmptyBoard(width, height, pieceSize)
{
    // Draw top border.
    drawSpriteSection(spriteSquareEmptyTL, 0, 0);
    for (x = 0; x < width; x++)
    {
        drawSpriteSection(spriteSquareEmptyT, pieceSize * (x + 1), 0);
    }
    drawSpriteSection(spriteSquareEmptyTR, pieceSize * (width + 1), 0);

    // Draw left border.
    for (y = 0; y < height; y++)
    {
        drawSpriteSection(spriteSquareEmptyL, 0, pieceSize * (y + 1));
    }
    
    // Draw right border.
    for (y = 0; y < height; y++)
    {
        drawSpriteSection(spriteSquareEmptyR, pieceSize * (width + 1), pieceSize * (y + 1));
    }
    
    // Draw bottom border.
    drawSpriteSection(spriteSquareEmptyBL, 0, pieceSize * (height + 1));
    for (x = 0; x < width; x++)
    {
        drawSpriteSection(spriteSquareEmptyB, pieceSize * (x + 1), pieceSize * (height + 1));
    }
    drawSpriteSection(spriteSquareEmptyBR, pieceSize * (width + 1), pieceSize * (height + 1));

    // Draw the inside.
    for (y = 0; y < height; y++)
    {
        for (x = 0; x < width; x++)
        {
            drawEmptyPieceAt(x, y, pieceSize);
        }
    }
}

//----------------------------------------------------------------------------
// Function that draws the next state (if possble).
function drawMoveNext()
{
    if (gameMoveCurrent < gameTurnMaxinum)
    {
        if (gamePlayerNext == "white")
        {
            drawWhitePieceAt
                ( gameReplay.moves[gameMoveCurrent].x
                , gameReplay.moves[gameMoveCurrent].y
                , gamePieceSize
                );
        }

        if (gamePlayerNext == "black")
        {
            drawBlackPieceAt
                ( gameReplay.moves[gameMoveCurrent].x
                , gameReplay.moves[gameMoveCurrent].y
                , gamePieceSize
                );
        }
    }
}

//----------------------------------------------------------------------------
// Function that draws the previous state (if possible).
function drawMovePrev()
{    
    if (gameMoveCurrent > 0)
    {
        drawEmptyPieceAt
            ( gameReplay.moves[gameMoveCurrent - 1].x
            , gameReplay.moves[gameMoveCurrent - 1].y
            , gamePieceSize
            );
    }
}

//----------------------------------------------------------------------------
// Function that draws empty piece at given position.
function drawEmptyPieceAt(px, py, pieceSize)
{
    drawSpriteSection(spriteSquareEmpty, pieceSize * (px + 1), pieceSize * (py + 1));
}

//----------------------------------------------------------------------------
// Function that draws white piece at given position.
function drawWhitePieceAt(px, py, pieceSize)
{
    drawSpriteSection(spriteSquareWhite, pieceSize * (px + 1), pieceSize * (py + 1));
}

//----------------------------------------------------------------------------
// Function that draws black piece at given position.
function drawBlackPieceAt(px, py, pieceSize)
{
    drawSpriteSection(spriteSquareBlack, pieceSize * (px + 1), pieceSize * (py + 1));
}

function drawSpriteSection(index, px, py)
{
    gameCanvas.drawImage
        ( gameImageSprite
        , spriteSectionData[index][0]
        , spriteSectionData[index][1]
        , spriteSectionData[index][2]
        , spriteSectionData[index][3]
        , px
        , py
        , spriteSectionData[index][2]
        , spriteSectionData[index][3]
        ); 
}
