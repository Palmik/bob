function visualize(url, size)
{
    loadReplay(url);
    pieceSize = size;
}

function initialize()
{
    $(document).ready(function()
    {
        gameCanvas = $("#game-canvas");
        gameCanvas.attr("width",  pieceSize * gameReplay.settings.columns);
        gameCanvas.attr("height", pieceSize * gameReplay.settings.rows);

        gameTurnMaximum = gameReplay.moves.length;

        $("#game-turn-display-maximum").text(gameTurnMaximum.toString());
        $("#game-turn-input").val("0");
        $("#game-turn-input").change(function()
        {
            var value = parseInt($("#game-turn-input").val(), 10);
            if (!isNaN(value))
            {
                setTurn(value);
            }
            $("#game-turn-input").val(gameTurnCurrent.toString());
        });

        drawEmptyBoard(gameReplay.settings.columns, gameReplay.settings.rows, pieceSize);

        $("#game-button-previous").click(function()
        {
            setTurn(gameTurnCurrent - 1);
        });

        $("#game-button-next").click(function()
        {
            setTurn(gameTurnCurrent + 1);
        });

        $("#game-button-play-pause").click(function()
        {
            togglePlay();
        });
    });
}

//----------------------------------------------------------------------------
// GLOBAL STATE

var gameReplay = {};
var gameCanvas = null;
var gameTurnCurrent = 0;
var gameTurnMaximum = 0;
var gamePlayerNext = "black"

var pieceSize = 32;

var playerIntervalID = null;
var playerPlaying = false;
var playerSpeed = 500;

function togglePlay()
{
    if (playerPlaying)
    {
        playerGamePause();
    }
    else
    {
        playerGameResume();
    }
}

function playerGameResume()
{
    playerIntervalID = window.setInterval(function()
    {
        setTurn(gameTurnCurrent + 1);
    }
    , playerSpeed);

    $("#game-icon-play-pause").attr("class", "icon-pause");
    playerPlaying = true;
}

function playerGamePause()
{
    clearInterval(playerIntervalID);
    $("#game-icon-play-pause").attr("class", "icon-play");
    playerPlaying = false;
}

function otherPlayer(player)
{
    if (player == "black") return "white";
    if (player == "white") return "black";
}

//----------------------------------------------------------------------------
// LOADING FUNCTION

function loadReplay(url)
{
    jQuery.getJSON(url, function(data)
    {
        gameReplay = data;
        gameTurnMaxinum = gameReplay.moves.length;
        initialize();
    });
}

//----------------------------------------------------------------------------
// LOADING FUNCTION

function setTurn(turn)
{
    turn = Math.min(Math.max(turn, 0), gameTurnMaximum);

    while (turn != gameTurnCurrent)
    {
        if (gameTurnCurrent > turn)
        {
            drawTurnPrev();
            gameTurnCurrent = gameTurnCurrent - 1; 
            gamePlayerNext = otherPlayer(gamePlayerNext);
        }
        if (gameTurnCurrent < turn)
        {
            drawTurnNext();
            gameTurnCurrent = gameTurnCurrent + 1;
            gamePlayerNext = otherPlayer(gamePlayerNext);
        }
    }

    if (gameTurnCurrent == gameTurnMaximum)
    {
        playerGamePause();
    }

    synchronizeUI();
}

function synchronizeUI()
{
    $("#game-turn-input").val(gameTurnCurrent.toString());
}

//----------------------------------------------------------------------------
// Function that draws an empty board.
function drawEmptyBoard(width, height, pieceSize)
{
    for (y = 0; y < width; y++)
    {
        for (x = 0; x < height; x++)
        {
            drawEmptyPieceAt(x, y, pieceSize);
        }
    }
}

//----------------------------------------------------------------------------
// Function that draws the next state (if possble).
function drawTurnNext()
{
    if (gameTurnCurrent < gameTurnMaxinum)
    {
        if (gamePlayerNext == "white")
        {
            drawBlackPieceAt(gameReplay.moves[gameTurnCurrent].x, gameReplay.moves[gameTurnCurrent].y, pieceSize);
        }

        if (gamePlayerNext == "black")
        {
            drawWhitePieceAt(gameReplay.moves[gameTurnCurrent].x, gameReplay.moves[gameTurnCurrent].y, pieceSize);
        }
    }
}

//----------------------------------------------------------------------------
// Function that draws the previous state (if possible).
function drawTurnPrev()
{    
    if (gameTurnCurrent > 0)
    {
        drawEmptyPieceAt(gameReplay.moves[gameTurnCurrent - 1].x, gameReplay.moves[gameTurnCurrent - 1].y, pieceSize);
    }
}

//----------------------------------------------------------------------------
// Function that draws empty piece at given position.
function drawEmptyPieceAt(px, py, pieceSize)
{
    gameCanvas.drawRect
    ({
        fillStyle:   "#FFFFFF",
        strokeStyle: "#000000",
        strokeWidth: 1,
        width:  pieceSize,
        height: pieceSize,
        x: (pieceSize / 2) + pieceSize * px,
        y: (pieceSize / 2) + pieceSize * py
    });
}

//----------------------------------------------------------------------------
// Function that draws white piece at given position.
function drawWhitePieceAt(px, py, pieceSize)
{
    gameCanvas.drawRect
    ({
        fillStyle:   "#FF0000",
        strokeStyle: "#000000",
        strokeWidth: 1,
        width:  pieceSize,
        height: pieceSize,
        x: (pieceSize / 2) + pieceSize * px,
        y: (pieceSize / 2) + pieceSize * py
    });
}

//----------------------------------------------------------------------------
// Function that draws black piece at given position.
function drawBlackPieceAt(px, py, pieceSize)
{
    gameCanvas.drawRect
    ({
        fillStyle:   "#0000FF",
        strokeStyle: "#000000",
        strokeWidth: 1,
        width:  pieceSize,
        height: pieceSize,
        x: (pieceSize / 2) + pieceSize * px,
        y: (pieceSize / 2) + pieceSize * py
    });
}
